# Notes of **A First Course in Database Systems**


|时间|内容|
|:---|:---|
|20190513|kick off.|

## 术语

<!-- 记录阅读过程中出现的关键字及其简单的解释. -->

## 介绍

<!-- 描述书籍阐述观点的来源、拟解决的关键性问题和采用的方法论等. -->

## 动机

<!-- 描述阅读书籍的动机, 要达到什么目的等. -->

## 概念结构

<!-- 描述书籍的行文结构, 核心主题和子主题的内容结构和关系. -->

#### 1 数据库系统世界

##### 1.1 数据库系统的发展
###### 1.1.1 早期的数据库管理系统
###### 1.1.2 关系数据库系统
###### 1.1.3 越来越小的系统
###### 1.1.4 越来越大的系统
###### 1.1.5 信息集成
##### 1.2 数据库管理系统概述
###### 1.2.1 数据定义语言命令
###### 1.2.2 查询处理概述
###### 1.2.3 存储器和缓冲区管理器
###### 1.2.4 事务处理
###### 1.2.5 查询处理器
##### 1.3 本书概述
##### 1.4 参考文献

### 第一部分 关系数据库模型
#### 2 关系数据模型
##### 2.1 数据模型概述
###### 2.1.1 什么是数据模型
###### 2.1.2 一些重要的数据模型
###### 2.1.3 关系模型简介
###### 2.1.4 半结构化模型简介
###### 2.1.5 其他数据模型
###### 2.1.6 几种建模方法的比较

##### 2.2 关系模型基础
###### 2.2.1 属性
###### 2.2.2 模式
###### 2.2.3 元组
###### 2.2.4 域
###### 2.2.5 关系的等价描述
###### 2.2.6 关系实例
###### 2.2.7 关系上的键
###### 2.2.8 数据库模式示例

Figure 2.5 - P.26



###### 2.2.9 习题

##### 2.3 在SQL中定义关系模式
###### 2.3.1 SQL中的关系
###### 2.3.2 数据类型
###### 2.3.3 简单的表定义
###### 2.3.4 修改关系模式
###### 2.3.5 默认值
###### 2.3.6 键的声明
###### 2.3.7 习题

##### 2.4 代数查询语言
###### 2.4.1 为什么需要一种专门的查询语言
###### 2.4.2 什么是代数
###### 2.4.3 关系代数概述
###### 2.4.4 关系上的集合操作
###### 2.4.5 投影
###### 2.4.6 选择
###### 2.4.7 笛卡儿积
###### 2.4.8 自然连接
###### 2.4.9 连接
###### 2.4.10 组合操作构成查询
###### 2.4.11 命名和重命名
###### 2.4.12 操作之间的联系
###### 2.4.13 代数表达式的线性符号
###### 2.4.14 习题

符号:

- $R,S$, : 集合
- $A_{i}$: 属性
- $C$: 条件

操作:

- union: $R \cup S$
- intersection: $R \cap S$
- difference: $R - S$
- projection: $\pi_{A_{1},A_{2}, \cdots, A_{n}}(R)$
- selection: $\sigma_{C}(R)$
- Cartesian product: $R \times S$
- natural join: $R \bowtie S$
- theta join: $R \bowtie_{C} S$
- renaming: $\rho_{S}(A_{1}, A_{2}, \cdots, A_{n})(R)$ 或者 $\rho_{S}(R)$, 结果名称为$S$, 属性为$A_{i}$

操作组合使用例: $\pi_{\texttt{title, year}}(\sigma_{\texttt{length} \geq 100 \texttt{AND} \texttt{studioName} = \texttt{'Fox'}} (\texttt{Movies}))$

操作间关系:

$$
R \cap S = R - (R - S) \\
R \bowtie_{C} S = \sigma_{C}(R \times S) \\
R \bowtie S = \pi_{L}(\sigma_{C}(R \times S))
$$

这里

- $C$的形式为: $R.A_{1} = S.A_{1} \texttt{AND} R.A_{2} = S.A_{2} \texttt{AND} \cdots \texttt{AND} R.A_{n} = S.A_{n}$,
- $A_{i}$是均在和中出现的属性,
- $L$为$R$和$S$中出现的属性.



##### 2.5 关系上的约束
###### 2.5.1 作为约束语言的关系代数
###### 2.5.2 引用完整性约束
###### 2.5.3 键约束
###### 2.5.4 其他约束举例
###### 2.5.5 习题
##### 2.6 小结
##### 2.7 参考文献


使用关系代数表达式描述约束的两种方式

$R, S$: 关系代数表达式

(1) $R=\varnothing$

(2) $R \subseteq S$


#### 3 关系数据库设计理论
##### 3.1 函数依赖
###### 3.1.1 函数依赖的定义
###### 3.1.2 关系的键
###### 3.1.3 超键
###### 3.1.4 习题
##### 3.2 函数依赖的规则
###### 3.2.1 函数依赖的推导
###### 3.2.2 分解／结合规则
###### 3.2.3 平凡函数依赖
###### 3.2.4 计算属性的闭包
###### 3.2.5 闭包算法为何有效
###### 3.2.6 传递规则
###### 3.2.7 函数依赖的闭包集合
###### 3.2.8 投影函数依赖
###### 3.2.9 习题
##### 3.3 关系数据库模式设计
###### 3.3.1 异常
###### 3.3.2 分解关系
###### 3.3.3 Boyce—Codd范式
###### 3.3.4 分解为BCNF
###### 3.3.5 习题
##### 3.4 分解的优劣
###### 3.4.1 从分解中恢复信息
###### 3.4.2 无损连接的chase检验
###### 3.4.3 为什chase检验有效
###### 3.4.4 依赖的保持
###### 3.4.5 习题
##### 3.5 第三范式
###### 3.5.1 第三范式的定义
###### 3.5.2 3NF模式综合算法
###### 3.5.3 为什么3NF综合算法有效
###### 3.5.4 习题
##### 3.6 多值依赖
###### 3.6.1 属性独立及随之产生的冗余
###### 3.6.2 多值依赖的定义
###### 3.6.3 多值依赖的推导
###### 3.6.4 第四范式
###### 3.6.5 分解为第四范式
###### 3.6.6 范式间的联系
###### 3.6.7 习题
##### 3.7 MVD的发现算法
###### 3.7.1 闭包和chase
###### 3.7.2 将chase扩展到MVD
###### 3.7.3 chase为何对MVD有效
###### 3.7.4 投影MVD
###### 3.7.5 习题
##### 3.8 小结
##### 3.9 参考文献

#### 4 高级数据库模型
##### 4.1 E/R模型
###### 4.1.1 实体集
###### 4.1.2 属性
###### 4.1.3 联系
###### 4.1.4 实体一联系图
###### 4.1.5 E/R图实例
###### 4.1.6 二元E/R联系的多样性
###### 4.1.7 多路联系
###### 4.1.8 联系中的角色
###### 4.1.9 联系的属性
###### 4.1.10 多路联系到二元联系的转换
###### 4.1.11 E/R模型中的子类
###### 4.1.12 习题
##### 4.2 设计原则
###### 4.2.1 忠实性
###### 4.2.2 避免冗余
###### 4.2.3 简单性
###### 4.2.4 选择正确的联系
###### 4.2.5 选择正确的元素种类
###### 4.2.6 习题_
##### 4.3 E/R模型中的约束
###### 4.3.1 E/R模型中的键
###### 4.3.2 E/R模型中键的表示
###### 4.3.3 引用完整性
###### 4.3.4 度约束
###### 4.3.5 习题
##### 4.4 弱实体集
###### 4.4.1 弱实体集的来源
###### 4.4.2 弱实体集的要求
###### 4.4.3 弱实体集的符号
###### 4.4.4 习题
##### 4.5 从E/R图到关系设计
###### 4.5.1 实体集到关系的转化
###### 4.5.2 E/R联系到关系的转化
###### 4.5.3 关系组合
###### 4.5.4 处理弱实体集
###### 4.5.5 习题
##### 4.6 子类结构到关系的转化
###### 4.6.1 E/R方式转化
###### 4.6.2 面向对象方法
###### 4.6.3 使用空值组合关系
###### 4.6.4 各种方法的比较
###### 4.6.5 习题
##### 4.7 统一建模语言
###### 4.7.1 UML类
###### 4.7.2 UML类的键
###### 4.7.3 关联
###### 4.7.4 自关联
###### 4.7.5 关联类
###### 4.7.6 UML中的子类
###### 4.7.7 聚集与组合
###### 4.7.8 习题
##### 4.8 UML图到关系的转化
###### 4.8.1 UML到关系的基础知识
###### 4.8.2 从UML子类到关系
###### 4.8.3 从聚集与组合到关系
###### 4.8.4 UML与弱实体集的类比
###### 4.8.5 习题
##### 4.9 对象定义语言
###### 4.9.1 类声明
###### 4.9.2 ODL中的属性
###### 4.9.3 ODL中的联系
###### 4.9.4 反向联系
###### 4.9.5 联系的多重性
###### 4.9.6 ODL中的类型
###### 4.9.7 ODL冲的子类
###### 4.9.8 在ODL冲声明键
###### 4.9.9 习题
##### 4.10 从ODL设计到关系设计
###### 4.10.1 从ODL类到关系
###### 4.10.2 类中的复杂属性
###### 4.10.3 值集合类型属性的表示
###### 4.10.4 其他类型构建器的表示
###### 4.10.5 ODL中联系的表示
###### 4.10.6 习题
##### 4.11小结
##### 4.12参考文献

### 第二部分 关系数据库程序设计
#### 5 代数和逻辑查询语言
##### 5.1 包上的关系操作
###### 5.1.1 为什么采用包
###### 5.1.2 包的并、交、差
###### 5.1.3 包上的投影操作
###### 5.1.4 包上的选择操作
###### 5.1.5 包的笛卡儿积
###### 5.1.6 包的连接
###### 5.1.7 习题

bags: multisets

- $R,S$ : 包
- $t$: 元组
- 元组$t$在$R$中出现$n$次, 在$S$中出现$m$次

- bag union: $R \cup S$, $t$出现$n+m$次
- bag intersection: $R \cap S$, $t$出现$\texttt{min}(n,m)$次
- bag difference: $R - S$, $t$出现$\texttt{max}(0,n-m)$次
- bag selection: $\sigma_{C}(R)$
- bag projection: $\pi_{A_{1},A_{2}, \cdots, A_{n}}(R)$
- Cartesian product of bag: $R \times S$
- natural join: $R \bowtie S$
- theta join: $R \bowtie_{C} S$
- renaming: $\rho_{S}(A_{1}, A_{2}, \cdots, A_{n})(R)$ 或者 $\rho_{S}(R)$, 结果名称为$S$, 属性为$A_{i}$

##### 5.2 关系代数的扩展操作符
###### 5.2.1 消除重复
###### 5.2.2 聚集操作符
###### 5.2.3 分组
###### 5.2.4 分组操作符
###### 5.2.5 扩展的投影操作符
###### 5.2.6 排序操作符
###### 5.2.7 外连接
###### 5.2.8 习题


duplicate-elimination operators: $\delta)R$

aggregation operators: $\texttt{SUM}, \texttt{AVG}, \texttt{MAX}, \texttt{MIN}, \texttt{COUNT}$

grouping: $\gamma_{L}(R)$; $L$是: <br/>
(1) $R$上的属性;<br/>
(2) $R$上属性的聚合操作符.

extended projection: $\pi_{L}(R)$, 列上计算; $L$中元素是: <br/>
(1) $R$上属性; <br/>
(2) 重命名 $x \rightarrow \y$,  $x,y$为属性名称; <br/>
(3) $E \rightarrow z$, $E$是包含上属性/常量/算数操作符/字符串操作符的表达式, $z$是表示$E$结果的名称.

sorting operators: $\tau_{L}(R)$; $L$是属性列表

outer join operators: $R \overset{\circ}{\bowtie} S$

null symbol: $\bot$

left outer join: $\overset{\circ}{\bowtie}_{L}$

right outer join: $\overset{\circ}{\bowtie}_{R}$

theta outer join: $\overset{\circ}{\bowtie}_{C}$

##### 5.3 关系逻辑
###### 5.3.1 谓词和原子
###### 5.3.2 算术原子
###### 5.3.3 Datalog规则和查询
###### 5.3.4 Datalog规则的意义
###### 5.3.5 扩展谓词和内涵谓词
###### 5.3.6 Datalog规则应用于包
###### 5.3.7 习题

logical query language Datalog(database logic), 由if-then规则构成.

每个规则说明组合特定关系中元组, 可以推断其他元组必在一个关系或是查询的结果.

##### 5.4 关系代数与Datalog
###### 5.4.1 布尔操作
###### 5.4.2 投影
###### 5.4.3 选择
###### 5.4.4 积
###### 5.4.5 连接
###### 5.4.6 用Datalog模拟多重操作
###### 5.4.7 Datalog与关系代数的比较
###### 5.4.8 习题




##### 5.5 小结
##### 5.6 参考文献

#### 6 数据库语言SQL
##### 6.1 SQL中的简单查询
###### 6.1.1 SQL中的投影
###### 6.1.2 SQL冲的选择
###### 6.1.3 字符串比较
###### 6.1.4 SQL中的模式匹配
###### 6.1.5 日期和时间
###### 6.1.6 空值和涉及空值的比较
###### 6.1.7 布尔值UNKNOWN

三值逻辑: Figure 6.2


###### 6.1.8 输出排序
###### 6.1.9 习题

##### 6.2 多关系查询
###### 6.2.1 SQL中的积和连接
###### 6.2.2 消除属性歧义
###### 6.2.3 元组变量
###### 6.2.4 多关系查询的解释
###### 6.2.5 查询的并、交、差
###### 6.2.6 习题

##### 6.3 子查询
###### 6.3.1 产生标量值的子查询
###### 6.3.2 关系的条件表达式
###### 6.3.3 元组的条件表达式
###### 6.3.4 关联子查询
###### 6.3.5 FROM子句中的子查询
###### 6.3.6 SQL的连接表达式
###### 6.3.7 自然连接
###### 6.3.8 外连接
###### 6.3.9 习题

##### 6.4 全关系操作
##### 64.1 消除重复
###### 6.4.2 并、交、差中的重复
###### 6.4.3 SQL中的分组和聚集
###### 6.4.4 聚集操作符
###### 6.4.5 分组
###### 6.4.6 分组、聚集和空值
###### 6.4.7 HAVING子句
###### 6.4.8 习题

##### 6.5 数据库更新
###### 6.5.1 插入
###### 6.5.2 删除
###### 6.5.3 修改
###### 6.5.4 习题

##### 6.6 SQL中的事务
###### 6.6.1 可串行化
###### 6.6.2 原子性
###### 6.6.3 事务
###### 6.6.4 只读事务
###### 6.6.5 读脏数据
###### 6.6.6 其他隔离层次
###### 6.6.7 习题

##### 6.7 小结
##### 6.8 参考文献

#### 7 约束与触发器
##### 7.1 键和外键
###### 7.1.1 外键约束声明
###### 7.1.2 维护引用完整性
###### 7.1.3 延迟约束检查
###### 7.1.4 习题
##### 7.2 属性和元组上的约束
###### 7.2.1 非空值约束
###### 7.2.2 基于属性的CHECK约束
###### 7.2.3 基于元组的CHECK约束
###### 7.2.4 基于元组和基于屙陛的约束的比较
###### 7.2.5 习题
##### 7.3 修改约束
###### 7.3.1 给约束命名
###### 7.3.2 修改表上的约束
###### 7.3.3 习题
##### 7.4 断言
###### 7.4.1 创建断言
###### 7.4.2 使用断言
###### 7.4.3 习题
##### 7.5 触发器
###### 7.5.1 SQL中的触发器
###### 7.5.2 触发器设计的选项
###### 7.5.3 习题
##### 7.6 小结
##### 7.7 参考文献

#### 8 视图与索引

##### 8.1 虚拟视图
###### 8.1.1 视图定义
###### 8.1.2 视图查询
###### 8.1.3 属性重命名
###### 8.1.4 习题
##### 8.2 视图更新

#### 9 SQL in a Server Environment

#### 10 Advanced Topics in Relational Databases



### 第三部分 半结构化数据的建模和程序设计
#### 11 The Semistructured-Data Model


#### 12 Programming Languages for XML


## 总结

<!-- 概要记录书籍中如何解决关键性问题的. -->

## 应用

<!-- 记录如何使用书籍中方法论解决你自己的问题. -->

## 文献引用

<!-- 记录相关的和进一步阅读资料: 文献、网页链接等. -->

```
@Book{Ullman2008,
  title     = {A First Course in Database Systems},
  publisher = {机械工业出版社},
  year      = {2008},
  author    = {Jeffrey D. Ullman, Jennifer Widom},
  edition   = {3},
  groups    = {Overview},
}
```

## 其他备注
